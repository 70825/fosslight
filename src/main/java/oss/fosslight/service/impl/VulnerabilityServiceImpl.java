/*
 * Copyright (c) 2021 LG Electronics Inc.
 * SPDX-License-Identifier: AGPL-3.0-only 
 */

package oss.fosslight.service.impl;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Service;

import lombok.extern.slf4j.Slf4j;
import oss.fosslight.CoTopComponent;
import oss.fosslight.common.CoCodeManager;
import oss.fosslight.common.CoConstDef;
import oss.fosslight.common.CommonFunction;
import oss.fosslight.domain.CoMail;
import oss.fosslight.domain.CoMailManager;
import oss.fosslight.domain.OssMaster;
import oss.fosslight.domain.T2CodeDtl;
import oss.fosslight.domain.Vulnerability;
import oss.fosslight.repository.CodeMapper;
import oss.fosslight.repository.OssMapper;
import oss.fosslight.repository.VulnerabilityMapper;
import oss.fosslight.service.OssService;
import oss.fosslight.service.VulnerabilityService;

@Service
@Slf4j
public class VulnerabilityServiceImpl extends CoTopComponent implements VulnerabilityService {
	private static final Logger scheduler_log = LoggerFactory.getLogger("SCHEDULER_LOG");

	@Autowired Environment env;
	@Autowired VulnerabilityMapper vulnerabilityMapper;
	@Autowired OssService ossService;
	@Autowired OssMapper ossMapper;
	@Autowired CodeMapper codeMapper;
	
	@Override
	public HashMap<String, Object> getVulnerabilityList(Vulnerability vulnerability, boolean exportFlag) {
		HashMap<String, Object> map = new HashMap<String, Object>();
		List<String> convertOssNicknameList = new ArrayList<>();
		List<String> vendorProductCheckList = new ArrayList<>();
		
		// Table alias 지정이 필요한 칼럼
		Map<String, String> ambiguousMap = new HashMap<>();
		ambiguousMap.put("CVE_ID", "T1");
		String filterCondition = CommonFunction.getFilterToString(vulnerability.getFilters(), ambiguousMap);
		if (!isEmpty(filterCondition)) {
			vulnerability.setFilterCondition(filterCondition);
		}
		
		if (isEmpty(vulnerability.getOssNameAllSearchFlag())) {
			vulnerability.setOssNameAllSearchFlag(CoConstDef.FLAG_NO);
		}
		
		if (CoConstDef.FLAG_YES.equals(vulnerability.getOssNameAllSearchFlag()) && "PRODUCT".equals(vulnerability.getSidx().toUpperCase())) {
			vulnerability.setSidx("version");
			vulnerability.setSord("desc");
		}
		
		if (vulnerability.getProduct() != null) {
			String searchProduct = vulnerability.getProduct();
			if (searchProduct.contains(" ") || searchProduct.contains("_")) {
				if (searchProduct.contains("_")) {
					vulnerability.setSpecialCharactersProduct(vulnerability.getProduct().replaceAll("_", " "));
				} else {
					vulnerability.setSpecialCharactersProduct(vulnerability.getProduct().replaceAll(" ", "_"));
				}
			}
			
			if (searchProduct.contains("-")) {
				vendorProductCheckList.add(searchProduct);
			}
		}
		
		String[] nicknameList = ossService.getOssNickNameListByOssName(vulnerability.getProduct());
		if (nicknameList != null) {
			for (String nickname : nicknameList) {
				if (nickname.contains(" ")) {
					convertOssNicknameList.add(nickname.replaceAll(" ", "_"));
				} else if (nickname.contains("_")) {
					convertOssNicknameList.add(nickname.replaceAll("_", " "));
				} else if (nickname.contains("-")) {
					vendorProductCheckList.add(nickname);
				}
			}
			
			if (convertOssNicknameList.size() > 0) {
				convertOssNicknameList.addAll(Arrays.asList(nicknameList));
				convertOssNicknameList = convertOssNicknameList.stream().distinct().collect(Collectors.toList());
				vulnerability.setOssNicknames(convertOssNicknameList.toArray(new String[convertOssNicknameList.size()]));
			} else {
				vulnerability.setOssNicknames(nicknameList);
			}
		} else {
			if (convertOssNicknameList.size() > 0) {
				convertOssNicknameList = convertOssNicknameList.stream().distinct().collect(Collectors.toList());
				vulnerability.setOssNicknames(convertOssNicknameList.toArray(new String[convertOssNicknameList.size()]));
			} else {
				vulnerability.setOssNicknames(nicknameList);
			}
		}
		
		if (!vendorProductCheckList.isEmpty()) {
			vendorProductCheckList = vendorProductCheckList.stream().distinct().collect(Collectors.toList());
			vulnerability.setOssNicknameArr(vendorProductCheckList.toArray(new String[vendorProductCheckList.size()]));
		}
		
		int records = vulnerabilityMapper.selectVulnerabilityTotalCount(vulnerability);
		vulnerability.setTotListSize(records);

		List<Vulnerability> list = null;
		if (exportFlag) {
			list = vulnerabilityMapper.selectVulnerabilityExportList(vulnerability);
		}else {
			list = vulnerabilityMapper.selectVulnerabilityList(vulnerability);
			List<String> replaceVendor = new ArrayList<>();
			for (Vulnerability vuln : list) {
				String vendor = vuln.getVendor();
				for (String vendorNm : vendor.split(",")) {
					if (!isEmpty(vendorNm)) {
						replaceVendor.add(vendorNm);
					}
				}
				vendor = "";
				if (replaceVendor.size() > 0) {
					for (String reNm : replaceVendor) {
						vendor += reNm + ",";
					}
					vuln.setVendor(vendor.substring(0, vendor.length()-1));
				} else {
					vuln.setVendor("");
				}
				replaceVendor.clear();
			}
		}

		map.put("page", vulnerability.getCurPage());
		map.put("total", vulnerability.getTotBlockSize());
		map.put("records", records);
		map.put("rows", list);
		return map;
	}
	
	@Override
	@Cacheable(value="autocompleteVulnerabilityCache", key="{#root.methodName}")
	public HashMap<String, Object> getVulnerabilityAutoComplete() {
		
		HashMap<String, Object> map = new HashMap<String, Object>();
		
		List<String> nameList = vulnerabilityMapper.selectVulnerabilityOSSNameAutoComplete();
		List<String> cveIdList = vulnerabilityMapper.selectVulnerabilityCveIdAutoComplete();
		
		map.put("nameList", nameList);
		map.put("cveIdList", cveIdList);

		return map;
	}

	@Override
	public List<String> getVulnerabilityVersionAutoComplete(String name) {

		List<String> versionList = vulnerabilityMapper.selectVulnerabilityOSSVersionAutoComplete(name);
		
		return versionList;
	}
	
	@Override
	public Map<String, Object> getVulnListByOssName(OssMaster bean) {
		Map<String, Object> result = new HashMap<String, Object>();
		
		if ("N/A".equals(bean.getOssVersion())) {
			bean.setOssVersion("");
		}
		
		List<Vulnerability> list = null;
		String[] nicknameList = null;
		List<String> convertNicknameList = null;
		List<String> vendorProductSearchList = new ArrayList<>();
		boolean convertFlag = false;
		int records = 0;
		
		try {
			nicknameList = ossService.getOssNickNameListByOssName(bean.getOssName());
			if(nicknameList.length == 0) {
				if (bean.getOssName().contains("_")) {
					bean.setOssName(bean.getOssName().replaceAll("_", " "));
				}
				nicknameList = ossService.getOssNickNameListByOssName(bean.getOssName());
			}
			
			if (bean.getOssName().contains("-")) {
				vendorProductSearchList.add(bean.getOssName());
			}
			
			if(nicknameList.length > 0) {
				for (String nick : nicknameList) {
					if (nick.contains(" ")) {
						if (!convertFlag) {
							convertNicknameList = new ArrayList<>();
							convertFlag = true;
						}
						convertNicknameList.add(nick.replaceAll(" ", "_"));
					}
					
					if (nick.contains("-")) {
						vendorProductSearchList.add(nick);
					}
				}
				
				if (convertNicknameList != null && !convertNicknameList.isEmpty()) {
					if (bean.getOssName().contains(" ")) convertNicknameList.add(bean.getOssName().replaceAll(" ", "_"));
					convertNicknameList.addAll(Arrays.asList(nicknameList));
					convertNicknameList = convertNicknameList.stream().distinct().collect(Collectors.toList());
					nicknameList = convertNicknameList.toArray(new String[convertNicknameList.size()]);
				} else {
					if (bean.getOssName().contains(" ")) {
						convertNicknameList = new ArrayList<>();
						convertNicknameList.add(bean.getOssName().replaceAll(" ", "_"));
						convertNicknameList.addAll(Arrays.asList(nicknameList));
						convertNicknameList = convertNicknameList.stream().distinct().collect(Collectors.toList());
						nicknameList = convertNicknameList.toArray(new String[convertNicknameList.size()]);
					}
				}
			} else {
				if (bean.getOssName().contains(" ")) {
					nicknameList = new String[] {bean.getOssName().replaceAll(" ", "_")};
				}
			}
			
			if (vendorProductSearchList != null && !vendorProductSearchList.isEmpty()) {
				bean.setOssNicknameArr(vendorProductSearchList.toArray(new String[vendorProductSearchList.size()]));
			}
			
			bean.setOssNicknames(nicknameList);
			records = vulnerabilityMapper.getVulnListByOssNameCnt(bean);
			bean.setTotListSize(records);
			list = vulnerabilityMapper.getVulnListByOssName(bean);
		} catch (Exception e) {
			log.error(e.getMessage());
		}
		
		list = checkVulnData(list, nicknameList);
		
		result.put("page", bean.getCurPage());
		result.put("total", bean.getTotBlockSize());
		result.put("records", records); // total cnt를 cveCnt에 담아두고 관리함.
		result.put("rows", list);
		
		return result;
	}
	
	public List<Vulnerability> checkVulnData(List<Vulnerability> list, String[] nicknameList){
		List<Vulnerability> result = new ArrayList<Vulnerability>();
				
		for (Vulnerability bean : list) {
			bean.setOssNameAllSearchFlag(CoConstDef.FLAG_YES);
			if (nicknameList != null) {
				bean.setOssNicknames(nicknameList);
			}
			int vulnCnt = vulnerabilityMapper.checkVulnDataCnt(bean);
			if (vulnCnt > 0) {
				result.add(bean);
			}
		}
		
		return result;
	}
	

	public void doSyncOSSNvdInfo() {

		vulnerabilityMapper.updateOssRecheckVulnFlag();

		List<String> notUsedOssList = new ArrayList<>();
		Map<String, OssMaster> reCalcOssInfoMap = new HashMap<>();
		List<String> _prjMailList = new ArrayList<>();
		List<String> _reCalcPrjMailList = new ArrayList<>();
		List<String> _removeReCalcPrjMailList = new ArrayList<>();
		Map<String, OssMaster> ossInfoMap = CoCodeManager.OSS_INFO_BY_ID;
		List<String> checkedOssList = new ArrayList<>();
		List<Map<String, Object>> _nvdInfoDiffVendorList = new ArrayList<>();
		boolean hasNvdData = vulnerabilityMapper.selectNvdTotalCount() > 0;
		
		T2CodeDtl codeDetail = codeMapper.getCodeDetail(CoConstDef.CD_VULNERABILITY_MAILING_SCORE, CoConstDef.CD_VULNERABILITY_MAILING_SCORE_STANDARD);
		String standardScore = codeDetail.getCdDtlExp();
		
		List<String> nvdInfoKeyList = new ArrayList<>();
		List<String> nvdInfoValueList = null;
		List<String> ossNicknameList = null;
		List<String> containsDashNameList = null;
		boolean convertNicknameFlag = false;
		boolean containsDashNameFlag = false;
		Map<String, List<String>> diffVendorList = new HashMap<>();
		scheduler_log.info("doSyncOSSNvdInfo standard cvss score : " + standardScore);
		for (String ossKey : ossInfoMap.keySet()) {
			OssMaster ossBean = ossInfoMap.get(ossKey);
			if (checkedOssList.contains(ossBean.getOssId())) {
				continue;
			}
			
			nvdInfoValueList = null;
			
			checkedOssList.add(ossBean.getOssId());
			ossBean.setOssVersion(avoidNull(ossBean.getOssVersion()));
			String ossName = ossBean.getOssName();
			String[] ossNicknames = ossBean.getOssNicknames();
			
			if (ossName.contains("-")) {
				if (!convertNicknameFlag) {
					containsDashNameList = new ArrayList<>();
					containsDashNameFlag = true;
				}
				containsDashNameList.add(ossName);
			}
			
			if (ossNicknames != null && ossNicknames.length > 0) {
				for (String nickname : ossNicknames) {
					if (nickname.contains(" ")) {
						if (!convertNicknameFlag) {
							ossNicknameList = new ArrayList<>();
							convertNicknameFlag = true;
						}
						ossNicknameList.add(nickname.replaceAll(" ", "_"));
					} else if (nickname.contains("-")) {
						if (!containsDashNameFlag) {
							containsDashNameList = new ArrayList<>();
							containsDashNameFlag = true;
						}
						containsDashNameList.add(nickname);
					}
				}
				
				if (ossNicknameList != null) {
					ossNicknameList.addAll(Arrays.asList(ossNicknames));
					if (ossBean.getOssName().trim().contains(" ")) {
						ossNicknameList.add(ossBean.getOssName().trim().replaceAll(" ", "_"));
					}
					ossBean.setOssNicknames(ossNicknameList.toArray(new String[ossNicknameList.size()]));
				} else {
					if (ossBean.getOssName().trim().contains(" ")) {
						ossNicknameList = new ArrayList<>();
						ossNicknameList.addAll(Arrays.asList(ossNicknames));
						ossNicknameList.add(ossBean.getOssName().trim().replaceAll(" ", "_"));
						ossBean.setOssNicknames(ossNicknameList.toArray(new String[ossNicknameList.size()]));
					}
				}
				
				convertNicknameFlag = false;
				ossNicknameList = null;
			} else {
				if (ossBean.getOssName().trim().contains(" ")) {
					ossBean.setOssNicknames(new String[] {ossBean.getOssName().replaceAll(" ", "_")});
				}
			}
			
			if (containsDashNameFlag) {
				ossBean.setDashOssNameList(containsDashNameList.toArray(new String[containsDashNameList.size()]));
				containsDashNameFlag = false;
				containsDashNameList = null;
			}
			
			List<Map<String, Object>> nvdInfoList = vulnerabilityMapper.selectNvdInfo(ossBean);
			ossBean.setOssNicknames(ossNicknames);
			
			boolean reCheckNVDInfo = false;
			if (nvdInfoList != null && !nvdInfoList.isEmpty()) {
				if (nvdInfoList.size() > 1) {
					String nvdInfoKey = "";
					
					for (Map<String, Object> nvdInfo : nvdInfoList) {
						if (!isEmpty((String) nvdInfo.get("VENDOR"))) {
							nvdInfoKey = ((String) nvdInfo.get("VENDOR") + "|" + (String) nvdInfo.get("PRODUCT")).toUpperCase();
							if (!nvdInfoKeyList.contains(nvdInfoKey)) {
								if (diffVendorList.containsKey((String) nvdInfo.get("PRODUCT"))) {
									nvdInfoValueList = (List<String>) diffVendorList.get((String) nvdInfo.get("PRODUCT"));
									nvdInfoKeyList.add(nvdInfoKey);
									diffVendorList.replace((String) nvdInfo.get("PRODUCT"), nvdInfoValueList);
								} else {
									nvdInfoValueList = new ArrayList<>();
									nvdInfoKeyList.add(nvdInfoKey);
									nvdInfoValueList.add((String) nvdInfo.get("VENDOR") + "|" + (String) nvdInfo.get("CVE_ID"));
									diffVendorList.put((String) nvdInfo.get("PRODUCT"), nvdInfoValueList);
								}
							}
						}
					}
				}
				
				BigDecimal bdScore = new BigDecimal(String.valueOf(nvdInfoList.get(0).get("CVSS_SCORE")));
				BigDecimal bdOrgMasterScore = new BigDecimal(CommonFunction.avoidNull(ossBean.getCvssScore(), "0"));
				String cveId = String.valueOf(nvdInfoList.get(0).get("CVE_ID"));
				
				updateVulnAndMailing(ossBean, nvdInfoList.get(0), bdScore, bdOrgMasterScore, standardScore, cveId, _prjMailList, _reCalcPrjMailList, notUsedOssList, reCalcOssInfoMap);
			}

			// 일치하는 결과가 없고, OSS VERSION이 설정되어 있지 않은 경우 해당 OSS의 MAX SCORE를 등록한다.
			else if (isEmpty(ossBean.getOssVersion())) {
				Map<String, Object> nvdInfo2 = vulnerabilityMapper.selectNvdInfoWithOutVer(ossBean);
				ossName = ossBean.getOssName();
				if (nvdInfo2 != null && !nvdInfo2.isEmpty()) {

					BigDecimal bdScore = new BigDecimal(String.valueOf(nvdInfo2.get("CVSS_SCORE")));
					BigDecimal bdOrgMasterScore = new BigDecimal(CommonFunction.avoidNull(ossBean.getCvssScore(), "0"));
					String cveId = String.valueOf(nvdInfo2.get("CVE_ID"));
					// 현재 등록되어 있는 score와 cve_id가 일치하지 않으면 업데이트
					if ( !bdScore.equals(bdOrgMasterScore) || !cveId.equals(ossBean.getCveId())) {
						scheduler_log.info("Vulnerability updateOssVulnInfo OSS ID : " + ossBean.getOssId());
						ossBean.setCvssScoreTo(String.valueOf(nvdInfo2.get("CVSS_SCORE")));
						ossBean.setCveIdTo(String.valueOf(nvdInfo2.get("CVE_ID")));
						vulnerabilityMapper.insertNvdOssHis(ossBean);
						
						OssMaster newNVD = new OssMaster();
						newNVD.setOssId(ossBean.getOssId());
						newNVD.setCvssScore(ossBean.getCvssScoreTo());
						newNVD.setCveId(ossBean.getCveIdTo());
						vulnerabilityMapper.updateOssVulnInfoNew(newNVD);

						// score가 7.0 이상인 경우만 메일을 발송
						// 처음으로 9.0 이상 Score가 등록된 경우 (기존 Score가 9.0 미만이고 NVD update score가 9.0 이상인 경우)
						// vulnerability mail > base score changed from 9.0 to 8.0
						if (bdScore.compareTo(new BigDecimal(standardScore)) > -1 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) < 0) {
							String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
							ossBean.setOssNames(nickNameList);
							List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
							if (_prjList != null && !_prjList.isEmpty()) {
								_prjMailList.addAll(_prjList);
							}
							notUsedOssList.add(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion());
						}
						
						// NVD Score가 9.0 미만이면서 기존 Score가 9.0 이상인 경우, Score가 변경되었음을 메일로 통지
						// vulnerability mail > base score changed from 9.0 to 8.0
						if (bdScore.compareTo(new BigDecimal(standardScore)) < 0 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) > -1) {
							String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
							ossBean.setOssNames(nickNameList);
							List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
							if (_prjList != null && !_prjList.isEmpty()) {
								_reCalcPrjMailList.addAll(_prjList);
							}
							reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
						}
					}
				} else {
					if (ossName.contains(" ")) {
						ossBean.setOssName(ossName.replaceAll(" ", "_"));
						Map<String, Object> nvdInfo3 = vulnerabilityMapper.selectNvdInfoWithOutVer(ossBean);
						
						if (nvdInfo3 != null && !nvdInfo3.isEmpty()) {

							BigDecimal bdScore = new BigDecimal(String.valueOf(nvdInfo3.get("CVSS_SCORE")));
							BigDecimal bdOrgMasterScore = new BigDecimal(CommonFunction.avoidNull(ossBean.getCvssScore(), "0"));
							String cveId = String.valueOf(nvdInfo3.get("CVE_ID"));
							// 현재 등록되어 있는 score와 cve_id가 일치하지 않으면 업데이트
							if ( !bdScore.equals(bdOrgMasterScore) || !cveId.equals(ossBean.getCveId())) {
								scheduler_log.info("Vulnerability updateOssVulnInfo OSS ID : " + ossBean.getOssId());
								ossBean.setCvssScoreTo(String.valueOf(nvdInfo3.get("CVSS_SCORE")));
								ossBean.setCveIdTo(String.valueOf(nvdInfo3.get("CVE_ID")));
								vulnerabilityMapper.insertNvdOssHis(ossBean);
								
								OssMaster newNVD = new OssMaster();
								newNVD.setOssId(ossBean.getOssId());
								newNVD.setCvssScore(ossBean.getCvssScoreTo());
								newNVD.setCveId(ossBean.getCveIdTo());
								vulnerabilityMapper.updateOssVulnInfoNew(newNVD);

								// score가 7.0 이상인 경우만 메일을 발송
								// 처음으로 9.0 이상 Score가 등록된 경우 (기존 Score가 9.0 미만이고 NVD update score가 9.0 이상인 경우)
								// vulnerability mail > base score changed from 9.0 to 8.0
								if (bdScore.compareTo(new BigDecimal(standardScore)) > -1 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) < 0) {
									String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
									ossBean.setOssNames(nickNameList);
									List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
									if (_prjList != null && !_prjList.isEmpty()) {
										_prjMailList.addAll(_prjList);
									}
									notUsedOssList.add(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion());
								}
								
								// NVD Score가 9.0 미만이면서 기존 Score가 9.0 이상인 경우, Score가 변경되었음을 메일로 통지
								// vulnerability mail > base score changed from 9.0 to 8.0
								if (bdScore.compareTo(new BigDecimal(standardScore)) < 0 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) > -1) {
									String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
									ossBean.setOssNames(nickNameList);
									List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
									if (_prjList != null && !_prjList.isEmpty()) {
										_reCalcPrjMailList.addAll(_prjList);
									}
									reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
								}
							}
						
						} else {
							// NVD 삭제 여부를 체크한다.
							reCheckNVDInfo = true;
						}
					} else {
						// NVD 삭제 여부를 체크한다.
						reCheckNVDInfo = true;
					}
				}
			}
			else {
				// NVD 삭제 여부를 체크한다.
				reCheckNVDInfo = true;
			}

			// NVD 정보는 없지만 oss list에 nvd 정보가 이미 설정되어 있는 경우
			// NVD 사이트에서 Excluding 되었을 가능성이 높다 (삭제됨)
			if (reCheckNVDInfo) {
				// 혹시 BATCH에서 오류가 발생하여 NVD_DATA_SCORE_V3 테이블에 DATA 가 등록되지 않은 경우 
				// 모든 NVD DATA가 삭제되는 것을 방지하기 위해서 건수가 0건이상인지 확인한다.
				if (hasNvdData && !isEmpty(ossBean.getCveId())) {
					scheduler_log.info("Vulnerability deleteOssVulnInfo OSS ID : " + ossBean.getOssId());
					// oss list에서 NVD 정보를 삭제한다.
					ossBean.setCvssScoreTo("0");
					ossBean.setCveIdTo("");
					vulnerabilityMapper.insertNvdOssHis(ossBean);
					vulnerabilityMapper.deleteOssVulnInfo(ossBean.getOssId());
					
					BigDecimal bdOrgMasterScore = new BigDecimal(String.valueOf(ossBean.getCvssScore()));
					
					// vulnerability mail > base score changed from 9.0 to 8.0
					if (bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) > -1) {
						String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
						ossBean.setOssNames(nickNameList);
						List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
						if (_prjList != null && !_prjList.isEmpty()) {
							_removeReCalcPrjMailList.addAll(_prjList);
						}
						
						reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
					}
				}
			}
		}
		
		if (diffVendorList.size() > 1) {
			Map<String, Object> map = new HashMap<>();
			String vendor = "";
			String cveId = "";
			
			for (String diffVendorKey : diffVendorList.keySet()) {
				List<String> diffVendor = diffVendorList.get(diffVendorKey);
				if (diffVendor.size() > 1) {
					for (String diff : diffVendor) {
						vendor += diff.split("[|]")[0] + ",";
						if (!cveId.contains(diff.split("[|]")[1])) {
							cveId += diff.split("[|]")[1] + ",";
						}
					}
					map.put("product", diffVendorKey);
					map.put("cveId", cveId.substring(0, cveId.length()-1));
					map.put("vendor", vendor.substring(0, vendor.length()-1));
					
					_nvdInfoDiffVendorList.add(map);
					vendor = "";
					cveId = "";
				}
			}
		}
		
		CoCodeManager.getInstance().refreshOssInfo();
		
		if (_prjMailList != null && !_prjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_prjMailList));
			scheduler_log.info("Vulnerability prj COUNT : " + prjMailList.size());
			for (String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT);
				mailBean.setParamPrjId(prjId);
				CoMailManager.getInstance().sendMail(mailBean);
			}
			
		}
		
		if (_reCalcPrjMailList != null && !_reCalcPrjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_reCalcPrjMailList));
			scheduler_log.info("Vulnerability risk recalculated prj COUNT : " + _reCalcPrjMailList.size());
			for (String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_RECALCULATED);
				mailBean.setParamPrjId(prjId);
				mailBean.setParamStandardScore(standardScore);
				mailBean.setParamOssInfoMap(reCalcOssInfoMap);
				CoMailManager.getInstance().sendMail(mailBean);
			}
			
		}
		
		if (_removeReCalcPrjMailList != null && !_removeReCalcPrjMailList.isEmpty()) {
			List<String> prjMailList = new ArrayList<String>(new HashSet<String>(_removeReCalcPrjMailList));
			scheduler_log.info("Vulnerability risk remove > recalculated prj COUNT : " + _removeReCalcPrjMailList.size());
			for (String prjId : prjMailList) {
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_REMOVE_RECALCULATED);
				mailBean.setParamPrjId(prjId);
				mailBean.setParamStandardScore(standardScore);
				mailBean.setParamOssInfoMap(reCalcOssInfoMap);
				CoMailManager.getInstance().sendMail(mailBean);
			}
			
		}
		
		if (!notUsedOssList.isEmpty()) {
			try {
				scheduler_log.info("Vulnerability notUsedOssList COUNT : " + notUsedOssList.size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_OSS);
				mailBean.setParamOssKey(notUsedOssList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
		
		if (reCalcOssInfoMap.keySet().size() > 0) {
			try {
				scheduler_log.info("Vulnerability reCalculated All COUNT : " + reCalcOssInfoMap.keySet().size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_PROJECT_RECALCULATED_ALL);
				ArrayList<String> keyList = new ArrayList<String>(reCalcOssInfoMap.keySet());
				mailBean.setParamOssKey(keyList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
		
		if (_nvdInfoDiffVendorList != null && _nvdInfoDiffVendorList.size() > 0) {
			try {
				scheduler_log.info("Vulnerability nvdInfoDiffVendorList COUNT : " + _nvdInfoDiffVendorList.size());
				CoMail mailBean = new CoMail(CoConstDef.CD_MAIL_TYPE_VULNERABILITY_NVDINFO_DIFF);
				mailBean.setParamList(_nvdInfoDiffVendorList);
				CoMailManager.getInstance().sendMail(mailBean);
			} catch (Exception e) {
				scheduler_log.error(e.getMessage(), e);
			}
		}
	}

	@Override
	public Map<String, Object> getCveInfo(String cveId) {
		return vulnerabilityMapper.getCveInfo(cveId);
	}

	public List<Map<String, Object>> selectMaxScoreNvdInfo(String product, String version){
		Map<String, Object> paramMap = new HashMap<String, Object>();

		paramMap.put("ossName", product);
		paramMap.put("ossVersion", version);
		paramMap.put("host", env.getProperty("server.domain"));

		List<Map<String, Object>> list = vulnerabilityMapper.selectMaxScoreNvdInfo(paramMap);
		
		if (product.contains(" ") && list == null) {
			paramMap.replace("ossName", product.replaceAll(" ", "_"));
			list = vulnerabilityMapper.selectMaxScoreNvdInfo(paramMap);
		}
		
		return list;
	}
	
	private void updateVulnAndMailing(OssMaster ossBean, Map<String, Object> nvdInfo, BigDecimal bdScore, BigDecimal bdOrgMasterScore, String standardScore, String cveId
			, List<String> _prjMailList, List<String> _reCalcPrjMailList, List<String> notUsedOssList, Map<String, OssMaster> reCalcOssInfoMap) {
		// 현재 등록되어 있는 score와 cve_id가 일치하지 않으면 업데이트
		if ( !bdScore.equals(bdOrgMasterScore) || !cveId.equals(ossBean.getCveId())) {
			ossBean.setCvssScoreTo(String.valueOf(nvdInfo.get("CVSS_SCORE")));
			ossBean.setCveIdTo(String.valueOf(nvdInfo.get("CVE_ID")));
			vulnerabilityMapper.insertNvdOssHis(ossBean);
			
			OssMaster newNVD = new OssMaster();
			newNVD.setOssId(ossBean.getOssId());
			newNVD.setCvssScore(ossBean.getCvssScoreTo());
			newNVD.setCveId(ossBean.getCveIdTo());
			vulnerabilityMapper.updateOssVulnInfoNew(newNVD);
		}

		// score가 7.0 이상인 경우만 메일을 발송
		// 처음으로 9.0 이상 Score가 등록된 경우 (기존 Score가 9.0 미만이고 NVD update score가 9.0 이상인 경우)
		// vulnerability mail > base score changed from 9.0 to 8.0
		if (bdScore.compareTo(new BigDecimal(standardScore)) > -1 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) < 0) {
			String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
			ossBean.setOssNames(nickNameList);
			List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
			if (_prjList != null && !_prjList.isEmpty()) {
				_prjMailList.addAll(_prjList);
			}
			notUsedOssList.add(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion());
		}
		
		// NVD Score가 9.0 미만이면서 기존 Score가 9.0 이상인 경우, Score가 변경되었음을 메일로 통지
		// vulnerability mail > base score changed from 9.0 to 8.0
		if (bdScore.compareTo(new BigDecimal(standardScore)) < 0 && bdOrgMasterScore.compareTo(new BigDecimal(standardScore)) > -1) {
			String[] nickNameList = ossMapper.checkNickNameRegOss(ossBean.getOssName()).toArray(new String[0]);
			ossBean.setOssNames(nickNameList);
			List<String> _prjList = vulnerabilityMapper.selectUsedVulnerabilityOssProject(ossBean);
			if (_prjList != null && !_prjList.isEmpty()) {
				_reCalcPrjMailList.addAll(_prjList);
			}
			reCalcOssInfoMap.put(ossBean.getOssName().toUpperCase()+"_"+ossBean.getOssVersion(), ossBean);
		}
	}
}
